<!DOCTYPE html>
<style>
    * {
        border: 0;margin: 0;padding: 0;
    }


</style>
<canvas id="c">

</canvas>


<script>
    const DEBUG = {
        TILE: true,
        FLUID: false,
    }

function LightenDarkenColor(col, amt) {
  
  var usePound = false;

  if (col[0] === "#") {
      col = col.slice(1);
      usePound = true;
  }

  var num = parseInt(col,16);

  var r = (num >> 16) + amt;

  if (r > 255) r = 255;
  else if  (r < 0) r = 0;

  var b = ((num >> 8) & 0x00FF) + amt;

  if (b > 255) b = 255;
  else if  (b < 0) b = 0;

  var g = (num & 0x0000FF) + amt;

  if (g > 255) g = 255;
  else if (g < 0) g = 0;

  return (usePound?"#":"") + (g | (b << 8) | (r << 16)).toString(16);

}


</script>

<script>
    c.width = window.innerWidth
    c.height = window.innerHeight

    ctx = c.getContext("2d")
    const cl = () => {
        
        ctx.fillStyle = "#131518"
        ctx.fillRect(0,0,window.innerWidth, window.innerHeight)
   
    }

    const map = [
        1, 1, 1, 1,
        1, 1, 1, 1,
        1, 1, 1, 1,
        1, 1, 1, 1,
    ]

    const elevations = [
        1,1,1,1,
        1,4,3,1,
        1,1,3,1,
        1,1,1,1,
    ]

    const curryClamp = (bMin, bMax) => (value) => {
        if(value < bMin) return bMin
        if(value > bMax) return bMax
        return value 
    }

    const zeroCentClamp = curryClamp(0, 100)


    //grid Helpers 

    // k,o,o
    // o,o,o
    // o,o,o

    const getNeighbors = (i) => {
        const nIds = []
        // 8 voisins
        if(i<mapW) { //1 ligne
            if(i === 0) {// coin haut gauche
                nIds.push(i + 1, i + mapW, i + mapW + 1)
            } else if(i === mapH * mapW - 1) {// coin haut droite 
                nIds.push(i - 1, i + mapW - 1, i + mapW)
            } else { // le reste
                nIds.push(i - 1,i + 1, i + mapW - 1, i + mapW, i + mapW + 1)
            }
        } else if(i > mapW * (mapH - 1)) { // dern ligne
            if(i === mapW * (mapH - 1)) { // coin bas gauche
                nIds.push(i - mapW, i - mapW + 1, i + 1)
            } else if(i === mapH * mapW - 1) { // coin bas droite
                nIds.push(i - mapW - 1, i - mapW, i - 1)
            } else {//le reste
                nIds.push(i - mapW - 1, i - mapW, i - mapW + 1, i - 1, i + 1)
            }
        } else if(i % mapW === 1) {//1ere colone
            nIds.push(i - mapW, i - mapW + 1, i + 1, i + mapW, i + mapW + 1)            
        } else if(i % mapW === 0) {//derniere colone
            nIds.push(i - mapW - 1, i - mapW, i - 1, i + mapW - 1, i + mapW + 1)
        } else { // le centre
            nIds.push(i - mapW - 1, i - mapW, i - mapW + 1, i - 1, i + 1, i + mapW - 1, i + mapW, i + mapW + 1)
        }
        return nIds

    }

    // FLUIDS
    const SOURCE_IDS = [0]

    let fluids = [
        0,0,0,0,
        0,0,0,0,
        0,0,0,0,
        0,0,0,0,
    ]

    const nextStepFluids = []

    const FLUID_PROPAGATION = 1
    const FLUID_GROWTH = 1
    const FLUID_LIMIT = 100

    const propagate = () => {
        for(let i  = 0; i < fluids.length; i++) {
            if(i === SOURCE_IDS[0]) {
                nextStepFluids[i] = zeroCentClamp(fluids[i] + FLUID_GROWTH)
                
            }
            if(fluids[i] >= FLUID_LIMIT) {
                const neighborsIds = getNeighbors(i)
                neighborsIds.forEach(id => {
                    nextStepFluids[id] = zeroCentClamp( fluids[id] + FLUID_GROWTH / neighborsIds.length )
                })
            } else {
                nextStepFluids[i] = fluids[i]
            }
        }
        fluids = nextStepFluids

    }

    const drawFluids = () => {
        for(let i = 0; i < mapW; i ++) {
            for(let j = 0; j < mapH; j ++) {
                const fluidProj = proj(j, i)
                if(DEBUG.FLUID) {

                    ctx.fillStyle="#000"
                    ctx.fillText(fluids[i * mapW + j].toFixed(1), fluidProj.x + camOffsetX + TILE_SIZE, fluidProj.y + camOffsetY)

                }
            }
        }
    }


    const colors = [
        "#343536",
        "#e6E7E8",
        "#904110",
        "#342222"//DARK RED
    ]

    const mapW = 4
    const mapH = 4

    let hoverCase = null



    const camOffsetX = 0
    const camOffsetY = 100
    const camOffsetZ = 0

    const TILE_SIZE = 30
    const ALPHA = 37//Â°
    const W = Math.sqrt(2) * TILE_SIZE
    const H = W * Math.sin(37 * Math.PI / 180) 

    const O_X = window.innerWidth / 2
    const O_Y = 0
    // AGENT
    let agX = 0
    let agY = 0
    let dirFlags = {}
    window.onkeydown = (e) => {
        dirFlags[e.code] = true  
    }
    window.onkeyup = (e) => {
        dirFlags[e.code] = false
    }




    const clearColor = (color) => {
        return LightenDarkenColor(color, 20)
    }

    const darkColor = (color) => {
        return LightenDarkenColor(color, -20)
    }

    const proj = (x, y) => {
        return {x: O_X + (x * W - y * W), y : O_Y + (x * H + y * H) }
    }

    const MOOVE_SPEED = .1
    const upAgent = () => {
        dirFlags['KeyW'] && (agY -= MOOVE_SPEED)
        dirFlags['KeyS'] && (agY += MOOVE_SPEED)  
        dirFlags['KeyA'] && (agX -= MOOVE_SPEED)
        dirFlags['KeyD'] && (agX += MOOVE_SPEED)         
    }

    const drawAgent = () => {
        const agPos = proj(agX, agY)
        ctx.fillRect(agPos.x + camOffsetX, agPos.y + camOffsetY, 10, 10)
    }

    const drawTile = (id, posX, posY, posZ, d) => {
        
        let color = colors[map[id]]
        if(fluids[id] === 100) {
            color = colors[3]
        }
        if(hoverCase && hoverCase === id) {
            color = "#00FF28"
        }

        ctx.beginPath()
        ctx.moveTo(posX + camOffsetX, posY - posZ + camOffsetY)
        ctx.lineTo(posX + camOffsetX + W, posY - posZ + camOffsetY + H)
        ctx.lineTo(posX + camOffsetX + W * 2, posY - posZ + camOffsetY)
        ctx.lineTo(posX + camOffsetX + W, posY - posZ + camOffsetY - H)
        ctx.closePath()
        ctx.fillStyle = color
        ctx.fill()

        ctx.beginPath()
        ctx.moveTo(posX + camOffsetX, posY - posZ + camOffsetY)
        ctx.lineTo(posX + camOffsetX, posY - posZ + camOffsetY + TILE_SIZE)
        ctx.lineTo(posX + camOffsetX + W, posY - posZ + camOffsetY + H + TILE_SIZE)
        ctx.lineTo(posX + camOffsetX + W, posY - posZ + camOffsetY + H)
        ctx.closePath()
        ctx.fillStyle = darkColor(color)
        ctx.fill()

        ctx.beginPath()
        ctx.moveTo(posX + camOffsetX + W * 2, posY - posZ + camOffsetY)
        ctx.lineTo(posX + camOffsetX + W * 2, posY - posZ + camOffsetY + TILE_SIZE)
        ctx.lineTo(posX + camOffsetX + W, posY - posZ + camOffsetY + H + TILE_SIZE)
        ctx.lineTo(posX + camOffsetX + W, posY - posZ + camOffsetY + H)
        ctx.closePath()
        ctx.fillStyle = clearColor(color)
        ctx.fill()
        if(DEBUG.TILE) {
         
            ctx.fillStyle = "#000"
            ctx.fillText(d, posX + camOffsetX + W, posY - posZ + camOffsetY + H / 2)
       
        }
    }


    const drawMap = () => {
        let d = 0
        for(let i = 0; i <= mapH + mapW; i ++) {
            for(let y = Math.max(0, i - mapH + 1); y <= Math.min(i, mapW - 1); y ++) {

                const x = i - y

                const tilePos = proj(x, y)
               
                const mindex = x + y * mapH
                for(let j = 0; j < elevations[mindex]; j ++) {
                    drawTile(mindex, tilePos.x, tilePos.y, H * j, mindex)
                }                        
            }
        }
    }

    document.onmousemove = (e) => {
        cx = (e.clientX)
        cy = (e.clientY)
            // {x: O_X + (x * W - y * W), y : O_Y + (x * H + y * H) }
        hoverCase = {x : cx - O_X, y : cy - O_Y}
        console.log(hoverCase)

    }
    const l = () => {
        cl()
        drawMap()
        upAgent()
        propagate()
        drawAgent()
        drawFluids()

        requestAnimationFrame(l)
    }
    l()

    
</script>